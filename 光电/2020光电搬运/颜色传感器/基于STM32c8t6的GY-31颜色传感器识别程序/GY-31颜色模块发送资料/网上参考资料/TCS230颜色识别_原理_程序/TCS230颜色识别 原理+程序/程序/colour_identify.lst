__text_start:
__start:
    007F EFCF      LDI	R28,0xFF
    0080 E1D0      LDI	R29,0x10
    0081 BFCD      OUT	0x3D,R28
    0082 BFDE      OUT	0x3E,R29
    0083 51C0      SUBI	R28,0x10
    0084 40D0      SBCI	R29,0
    0085 EA0A      LDI	R16,0xAA
    0086 8308      STD	Y+0,R16
    0087 2400      CLR	R0
    0088 E7E2      LDI	R30,0x72
    0089 E0F1      LDI	R31,1
    008A E011      LDI	R17,1
    008B 37E2      CPI	R30,0x72
    008C 07F1      CPC	R31,R17
    008D F011      BEQ	0x0090
    008E 9201      ST	R0,Z+
    008F CFFB      RJMP	0x008B
    0090 8300      STD	Z+0,R16
    0091 E8EC      LDI	R30,0x8C
    0092 E0F0      LDI	R31,0
    0093 E0A0      LDI	R26,0
    0094 E0B1      LDI	R27,1
    0095 E010      LDI	R17,0
    0096 3FEE      CPI	R30,0xFE
    0097 07F1      CPC	R31,R17
    0098 F021      BEQ	0x009D
    0099 95C8      LPM
    009A 9631      ADIW	R30,1
    009B 920D      ST	R0,X+
    009C CFF9      RJMP	0x0096
    009D 940E0206  CALL	_main
_exit:
    009F CFFF      RJMP	_exit
_delay_us:
  i                    --> R20
  j                    --> R22
  t                    --> R16
    00A0 940E0422  CALL	push_gset2
FILE: C:\DOCUME~1\Administrator\桌面\程序\12864.h
(0001) /**************************************************************
(0002) * 文件名 ：128_64.h
(0003) * 功能：实现单片机与LCD12864之间的串口通讯
(0004) * 说明 ：引脚接线：CS接PA0脚 SID接PA1脚 SCLK接PA2脚,PSB脚接地
(0005) **************************************************************/
(0006) #ifndef _12864_H
(0007) #define _12864_H
(0008) 
(0009) #include<iom128v.h>
(0010) #include<macros.h>
(0011) #include<BIT.h>    
(0012) 
(0013) #define CS _PA0                       
(0014) #define SID _PA1                     
(0015) #define SCLK _PA2                   
(0016) 
(0017) 
(0018) #define uchar unsigned char
(0019) #define uint unsigned int
(0020) 
(0021) 
(0022) void delay_us(uint t);                //函数功能： 16M晶振，延时t微秒
(0023) void delay_ms(uint t);                //函数功能： 16M晶振，延时t毫秒
(0024) void Sendbyte(uchar byte);        //函数功能：发送1字节
(0025) uchar Receivebyte(void);            //函数功能：串口接收一个字节
(0026)                                               //仅在读取数据的时候用到
(0027)                                               //而读出的数据是一次只能读出4bit的
(0028) void Checkbusy( void );             //函数功能：检测忙
(0029) void Writecommand(uchar data);  //函数功能：写命令
(0030) void Writedata(uchar data);        //函数功能：发送数据 
(0031) void Locate_x_y(uchar x,uchar y);//函数功能：光标定位x行y列                                            
(0032) void Write_string(uchar *s);        //函数功能：写入中文串                                  
(0033) void Display_x_y_symbol(uchar x,uchar y,uint data);
(0034)                                              //函数功能：以字码的形式录
(0035) void Display_x_y_data(uchar x,uchar y,uchar *data);
(0036)                                              //函数功能：光标定位x行y列写入中文串
(0037) void LcmClearTXT();                 //文本区清RAM函数  
(0038) void Init_12864(void);              //函数功能： 液晶初始化
(0039) 
(0040) 
(0041) 
(0042) //自动换行编码表
(0043) unsigned char AC_TABLE[]={
(0044) 0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,      //第一行汉字位置
(0045) 0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,      //第二行汉字位置
(0046) 0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,      //第三行汉字位置
(0047) 0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,      //第四行汉字位置
(0048) };
(0049) 
(0050) 
(0051) 
(0052) /**************************************************************
(0053) * 函数名称：delay_us()
(0054) * 函数功能：16M晶振，延时t微秒
(0055) * 入口参数：t    延时t微秒
(0056) * 出口参数：无
(0057) **************************************************************/
(0058) void delay_us(uint t)
(0059) { 
(0060)   	uint i,j;
(0061) 	 for(i=t;i>0;i--)
    00A2 01A8      MOVW	R20,R16
    00A3 C00A      RJMP	0x00AE
(0062) 	 	for(j=2;j>0;j--);
    00A4 E062      LDI	R22,2
    00A5 E070      LDI	R23,0
    00A6 C002      RJMP	0x00A9
    00A7 5061      SUBI	R22,1
    00A8 4070      SBCI	R23,0
    00A9 3060      CPI	R22,0
    00AA 0767      CPC	R22,R23
    00AB F7D9      BNE	0x00A7
    00AC 5041      SUBI	R20,1
    00AD 4050      SBCI	R21,0
    00AE 3040      CPI	R20,0
    00AF 0745      CPC	R20,R21
    00B0 F799      BNE	0x00A4
    00B1 940E0416  CALL	pop_gset2
    00B3 9508      RET
_delay_ms:
  i                    --> R20
  j                    --> R22
  t                    --> R16
    00B4 940E0422  CALL	push_gset2
(0063) } 
(0064) 
(0065) 
(0066) /**************************************************************
(0067) * 函数名称：delay_ms()
(0068) * 函数功能：16M晶振，延时t毫秒
(0069) * 入口参数：t   延时t毫秒
(0070) * 出口参数：无
(0071) **************************************************************/
(0072) void delay_ms(uint t)
(0073) {
(0074)  	 uint i,j;
(0075) 	 for(i=t;i>0;i--)
    00B6 01A8      MOVW	R20,R16
    00B7 C00A      RJMP	0x00C2
(0076) 	 	for(j=2800;j>0;j--);
    00B8 EF60      LDI	R22,0xF0
    00B9 E07A      LDI	R23,0xA
    00BA C002      RJMP	0x00BD
    00BB 5061      SUBI	R22,1
    00BC 4070      SBCI	R23,0
    00BD 3060      CPI	R22,0
    00BE 0767      CPC	R22,R23
    00BF F7D9      BNE	0x00BB
    00C0 5041      SUBI	R20,1
    00C1 4050      SBCI	R21,0
    00C2 3040      CPI	R20,0
    00C3 0745      CPC	R20,R21
    00C4 F799      BNE	0x00B8
    00C5 940E0416  CALL	pop_gset2
    00C7 9508      RET
_Sendbyte:
  i                    --> R20
  data                 --> R22
    00C8 940E0422  CALL	push_gset2
    00CA 2F60      MOV	R22,R16
(0077) }
(0078) 
(0079) 
(0080) /**************************************************************
(0081) * 函数名称：Sendbyte()
(0082) * 函数功能：发送1字节
(0083) * 入口参数：data   要写入的数据
(0084) * 出口参数：无
(0085) **************************************************************/
(0086) void Sendbyte(uchar data)
(0087) { 
(0088) 	uchar i=0;
    00CB 2744      CLR	R20
(0089) 	SCLK;
(0090) 	delay_us(8);										//针对高频晶振
    00CC E008      LDI	R16,0x8
    00CD E010      LDI	R17,0
    00CE DFD1      RCALL	_delay_us
(0091) 	for(i=0;i<8;i++)
    00CF C017      RJMP	0x00E7
(0092) 		{
(0093) 			if(data&0x80)
    00D0 FF67      SBRS	R22,7
    00D1 C004      RJMP	0x00D6
(0094) 				SID=1;
    00D2 B38B      IN	R24,0x1B
    00D3 6082      ORI	R24,2
    00D4 BB8B      OUT	0x1B,R24
    00D5 C003      RJMP	0x00D9
(0095) 			else 
(0096) 				SID=0;
    00D6 B38B      IN	R24,0x1B
    00D7 7F8D      ANDI	R24,0xFD
    00D8 BB8B      OUT	0x1B,R24
(0097) 			SCLK=1;
    00D9 B38B      IN	R24,0x1B
    00DA 6084      ORI	R24,4
    00DB BB8B      OUT	0x1B,R24
(0098) 			delay_us(8);								//针对高频晶振
    00DC E008      LDI	R16,0x8
    00DD E010      LDI	R17,0
    00DE DFC1      RCALL	_delay_us
(0099) 			data<<=1;
    00DF 0F66      LSL	R22
(0100) 			SCLK=0;
    00E0 B38B      IN	R24,0x1B
    00E1 7F8B      ANDI	R24,0xFB
    00E2 BB8B      OUT	0x1B,R24
(0101) 			delay_us(8);								//针对高频晶振
    00E3 E008      LDI	R16,0x8
    00E4 E010      LDI	R17,0
    00E5 DFBA      RCALL	_delay_us
    00E6 9543      INC	R20
    00E7 3048      CPI	R20,0x8
    00E8 F338      BCS	0x00D0
    00E9 940E0416  CALL	pop_gset2
    00EB 9508      RET
_Receivebyte:
  temp2                --> R16
  temp1                --> R18
  i                    --> R20
    00EC 940E0424  CALL	push_gset1
(0102) 		}
(0103) }
(0104) 
(0105) 
(0106) /**************************************************************
(0107) * 函数名称：Receivebyte()
(0108) * 函数功能：串口接收一个字节,仅在读取数据的时候用到,一次只能读出4bit的数据
(0109) * 入口参数：无
(0110) * 出口参数：(0xf0&temp1)+(0x0f&temp2)
(0111) **************************************************************/
(0112) uchar Receivebyte(void)
(0113) {
(0114)      uchar i,temp1,temp2;
(0115)      temp1=temp2=0;
    00EE 2700      CLR	R16
    00EF 2722      CLR	R18
(0116)      for(i=0;i<8;i++)
    00F0 2744      CLR	R20
    00F1 C010      RJMP	0x0102
(0117)      {
(0118)            temp1=temp1<<1;
    00F2 0F22      LSL	R18
(0119)            SCLK = 0;
    00F3 B38B      IN	R24,0x1B
    00F4 7F8B      ANDI	R24,0xFB
    00F5 BB8B      OUT	0x1B,R24
(0120)            SCLK = 1;            
    00F6 B38B      IN	R24,0x1B
    00F7 6084      ORI	R24,4
    00F8 BB8B      OUT	0x1B,R24
(0121)            SCLK = 0;
    00F9 B38B      IN	R24,0x1B
    00FA 7F8B      ANDI	R24,0xFB
    00FB BB8B      OUT	0x1B,R24
(0122)            if(SID) temp1++;
    00FC B38B      IN	R24,0x1B
    00FD 9586      LSR	R24
    00FE 7081      ANDI	R24,1
    00FF F009      BEQ	0x0101
    0100 9523      INC	R18
    0101 9543      INC	R20
    0102 3048      CPI	R20,0x8
    0103 F370      BCS	0x00F2
(0123)      }
(0124)      for(i=0;i<8;i++)
    0104 2744      CLR	R20
    0105 C010      RJMP	0x0116
(0125)      {
(0126)            temp2=temp2<<1;
    0106 0F00      LSL	R16
(0127)            SCLK = 0;
    0107 B38B      IN	R24,0x1B
    0108 7F8B      ANDI	R24,0xFB
    0109 BB8B      OUT	0x1B,R24
(0128)            SCLK = 1;
    010A B38B      IN	R24,0x1B
    010B 6084      ORI	R24,4
    010C BB8B      OUT	0x1B,R24
(0129)            SCLK = 0;
    010D B38B      IN	R24,0x1B
    010E 7F8B      ANDI	R24,0xFB
    010F BB8B      OUT	0x1B,R24
(0130)            if(SID) temp2++;
    0110 B38B      IN	R24,0x1B
    0111 9586      LSR	R24
    0112 7081      ANDI	R24,1
    0113 F009      BEQ	0x0115
    0114 9503      INC	R16
    0115 9543      INC	R20
    0116 3048      CPI	R20,0x8
    0117 F370      BCS	0x0106
(0131)      }
(0132)      return ((0xf0&temp1)+(0x0f&temp2));
    0118 2F80      MOV	R24,R16
    0119 708F      ANDI	R24,0xF
    011A 2F02      MOV	R16,R18
    011B 7F00      ANDI	R16,0xF0
    011C 0F08      ADD	R16,R24
    011D 940E0427  CALL	pop_gset1
    011F 9508      RET
(0133) }
(0134) 
(0135) /**************************************************************
(0136) * 函数名称：Checkbusy()
(0137) * 函数功能：液晶检测忙
(0138) * 入口参数：无
(0139) * 出口参数：无
(0140) **************************************************************/
(0141) void Checkbusy( void )
(0142) {
(0143)      do   Sendbyte(0xfc);                           //11111,RW(1),RS(0),0
_Checkbusy:
    0120 EF0C      LDI	R16,0xFC
    0121 DFA6      RCALL	_Sendbyte
(0144)      while(0x80&Receivebyte());                  //BF(.7)=1 Busy
    0122 DFC9      RCALL	_Receivebyte
    0123 FD07      SBRC	R16,7
    0124 CFFB      RJMP	_Checkbusy
    0125 9508      RET
_Writecommand:
  data                 --> R20
    0126 940E0424  CALL	push_gset1
    0128 2F40      MOV	R20,R16
(0145) }
(0146) 
(0147) /**************************************************************
(0148) * 函数名称：Writecommand()
(0149) * 函数功能：发送的是控制指令(数据从LCD到MCU)
(0150) * 入口参数：data   要写入的命令
(0151) * 出口参数：无
(0152) **************************************************************/
(0153) void Writecommand(uchar data)
(0154) { 
(0155) 	CS=1;
    0129 B38B      IN	R24,0x1B
    012A 6081      ORI	R24,1
    012B BB8B      OUT	0x1B,R24
(0156) 	Checkbusy();
    012C DFF3      RCALL	_Checkbusy
(0157) 	Sendbyte(0xf8); 							     //表示发送的是控制命令
    012D EF08      LDI	R16,0xF8
    012E DF99      RCALL	_Sendbyte
(0158) 	Sendbyte(data&0xf0);
    012F 2F04      MOV	R16,R20
    0130 7F00      ANDI	R16,0xF0
    0131 DF96      RCALL	_Sendbyte
(0159) 	Sendbyte((data&0x0f)<<4);
    0132 2F04      MOV	R16,R20
    0133 700F      ANDI	R16,0xF
    0134 700F      ANDI	R16,0xF
    0135 9502      SWAP	R16
    0136 DF91      RCALL	_Sendbyte
(0160) 	CS=0;
    0137 B38B      IN	R24,0x1B
    0138 7F8E      ANDI	R24,0xFE
    0139 BB8B      OUT	0x1B,R24
    013A 940E0427  CALL	pop_gset1
    013C 9508      RET
_Writedata:
  data                 --> R20
    013D 940E0424  CALL	push_gset1
    013F 2F40      MOV	R20,R16
(0161) }
(0162) /**************************************************************
(0163) * 函数名称：Writedata()
(0164) * 函数功能：向液晶写入数据 
(0165) * 入口参数：data   向液晶写入数据 
(0166) * 出口参数：无
(0167) **************************************************************/
(0168) void Writedata(uchar data)
(0169) {
(0170) 	CS=1;
    0140 B38B      IN	R24,0x1B
    0141 6081      ORI	R24,1
    0142 BB8B      OUT	0x1B,R24
(0171) 	Checkbusy();
    0143 DFDC      RCALL	_Checkbusy
(0172) 	Sendbyte(0xfa);								    //表示发送的是数据
    0144 EF0A      LDI	R16,0xFA
    0145 DF82      RCALL	_Sendbyte
(0173) 	Sendbyte(data&0xf0);  
    0146 2F04      MOV	R16,R20
    0147 7F00      ANDI	R16,0xF0
    0148 DF7F      RCALL	_Sendbyte
(0174) 	Sendbyte((data&0x0f)<<4);
    0149 2F04      MOV	R16,R20
    014A 700F      ANDI	R16,0xF
    014B 700F      ANDI	R16,0xF
    014C 9502      SWAP	R16
    014D DF7A      RCALL	_Sendbyte
(0175) 	CS=0;
    014E B38B      IN	R24,0x1B
    014F 7F8E      ANDI	R24,0xFE
    0150 BB8B      OUT	0x1B,R24
    0151 940E0427  CALL	pop_gset1
    0153 9508      RET
_Locate_x_y:
  addr                 --> R20
  y                    --> R22
  x                    --> R10
    0154 940E0420  CALL	push_gset3
    0156 2F62      MOV	R22,R18
    0157 2EA0      MOV	R10,R16
(0176) }
(0177) 
(0178) /**************************************************************
(0179) * 函数名称：Locate_x_y()
(0180) * 函数功能：光标定位x行y列
(0181) * 入口参数：X,Y   x行y列
(0182) * 出口参数：无
(0183) **************************************************************/
(0184) void Locate_x_y(uchar x,uchar y)
(0185) {
(0186) 	uchar addr=0x80;
    0158 E840      LDI	R20,0x80
(0187) 	Writecommand(0x80);
    0159 E800      LDI	R16,0x80
    015A DFCB      RCALL	_Writecommand
(0188) 	switch(x)
    015B 24BB      CLR	R11
    015C 20AA      TST	R10
    015D F411      BNE	0x0160
    015E 20BB      TST	R11
    015F F071      BEQ	0x016E
    0160 01C5      MOVW	R24,R10
    0161 3081      CPI	R24,1
    0162 E0E0      LDI	R30,0
    0163 079E      CPC	R25,R30
    0164 F061      BEQ	0x0171
    0165 3082      CPI	R24,2
    0166 E0E0      LDI	R30,0
    0167 079E      CPC	R25,R30
    0168 F059      BEQ	0x0174
    0169 3083      CPI	R24,3
    016A E0E0      LDI	R30,0
    016B 079E      CPC	R25,R30
    016C F051      BEQ	0x0177
    016D C00B      RJMP	0x0179
(0189) 	{
(0190) 		case 0: addr = 0x80 + y; break;
    016E 2F46      MOV	R20,R22
    016F 5840      SUBI	R20,0x80
    0170 C008      RJMP	0x0179
(0191) 		case 1:addr=0x90+y;break;
    0171 2F46      MOV	R20,R22
    0172 5740      SUBI	R20,0x70
    0173 C005      RJMP	0x0179
(0192) 		case 2:addr=0x88+y;break;
    0174 2F46      MOV	R20,R22
    0175 5748      SUBI	R20,0x78
    0176 C002      RJMP	0x0179
(0193) 		case 3:addr=0x98+y;break;
    0177 2F46      MOV	R20,R22
    0178 5648      SUBI	R20,0x68
(0194) 		default:break;
(0195) 	}
(0196) 	Writecommand(addr);
    0179 2F04      MOV	R16,R20
    017A DFAB      RCALL	_Writecommand
    017B 940E0419  CALL	pop_gset3
    017D 9508      RET
_Display_x_y_symbol:
  j                    --> R20
  i                    --> R22
  data                 --> Y+4
  y                    --> R22
  x                    --> R20
    017E 940E0422  CALL	push_gset2
    0180 2F62      MOV	R22,R18
    0181 2F40      MOV	R20,R16
(0197) }
(0198) /**************************************************************
(0199) * 函数名称：Display_x_y_symbol()
(0200) * 函数功能：以字码的形式写入一个中文
(0201) * 入口参数：X,Y,data   X行地址，Y列地址，data是字码
(0202) * 出口参数：无
(0203) **************************************************************/
(0204) void Display_x_y_symbol(uchar x,uchar y,uint data)
(0205) { 
(0206) 	uchar i,j;
(0207) 	Locate_x_y(x,y);
    0182 2F26      MOV	R18,R22
    0183 2F04      MOV	R16,R20
    0184 DFCF      RCALL	_Locate_x_y
(0208) 	j=(uchar)(data);
    0185 814C      LDD	R20,Y+4
    0186 815D      LDD	R21,Y+5
(0209) 	i=(uchar)(data>>8);
    0187 01BA      MOVW	R22,R20
    0188 2F67      MOV	R22,R23
    0189 2777      CLR	R23
(0210) 	Writedata(i);
    018A 2F06      MOV	R16,R22
    018B DFB1      RCALL	_Writedata
(0211) 	Writedata(j);
    018C 2F04      MOV	R16,R20
    018D DFAF      RCALL	_Writedata
    018E 940E0416  CALL	pop_gset2
    0190 9508      RET
_Write_string:
  s                    --> R20
    0191 940E0424  CALL	push_gset1
    0193 01A8      MOVW	R20,R16
(0212) }
(0213) /**************************************************************
(0214) * 函数名称：Write_string()
(0215) * 函数功能：写入串数据
(0216) * 入口参数：*s
(0217) * 出口参数：无
(0218) **************************************************************/
(0219) void Write_string(uchar *s)
(0220) { 
(0221) 	for(;*s!='\0';s++)
    0194 C005      RJMP	0x019A
(0222) 		{
(0223) 			Writedata(*s);
    0195 01FA      MOVW	R30,R20
    0196 8100      LDD	R16,Z+0
    0197 DFA5      RCALL	_Writedata
    0198 5F4F      SUBI	R20,0xFF
    0199 4F5F      SBCI	R21,0xFF
    019A 01FA      MOVW	R30,R20
    019B 8020      LDD	R2,Z+0
    019C 2022      TST	R2
    019D F7B9      BNE	0x0195
    019E 940E0427  CALL	pop_gset1
    01A0 9508      RET
_Display_x_y_data:
  data                 --> R20
  y                    --> R22
  x                    --> R10
    01A1 940E0420  CALL	push_gset3
    01A3 2F62      MOV	R22,R18
    01A4 2EA0      MOV	R10,R16
    01A5 814E      LDD	R20,Y+6
    01A6 815F      LDD	R21,Y+7
(0224) 		}
(0225) }
(0226) /**************************************************************
(0227) * 函数名称：Display_x_y_data()
(0228) * 函数功能：光标定位x行y列写入字符串,自动换行
(0229) * 入口参数：X,Y,data  
(0230) * 出口参数：无
(0231) **************************************************************/
(0232) void Display_x_y_data(uchar x,uchar y,uchar *data)
(0233) {
(0234) 	Writecommand(AC_TABLE[8*x+y]);
    01A7 E088      LDI	R24,0x8
    01A8 9D8A      MUL	R24,R10
    01A9 01F0      MOVW	R30,R0
    01AA 2E26      MOV	R2,R22
    01AB 2433      CLR	R3
    01AC 0DE2      ADD	R30,R2
    01AD 1DF3      ADC	R31,R3
    01AE E080      LDI	R24,0
    01AF E091      LDI	R25,1
    01B0 0FE8      ADD	R30,R24
    01B1 1FF9      ADC	R31,R25
    01B2 8100      LDD	R16,Z+0
    01B3 DF72      RCALL	_Writecommand
(0235) 	for(;*data!='\0';data++)
    01B4 C01B      RJMP	0x01D0
(0236) 		{
(0237) 			if(y==16)        						 //判断换行 换行后重写地址
    01B5 3160      CPI	R22,0x10
    01B6 F499      BNE	0x01CA
(0238) 				{            							//若不判断,则自动从第一行到第三行
(0239) 					y=0;
    01B7 2766      CLR	R22
(0240) 					x++;
    01B8 94A3      INC	R10
(0241) 					if (x==4) x=0;
    01B9 2D8A      MOV	R24,R10
    01BA 3084      CPI	R24,4
    01BB F409      BNE	0x01BD
    01BC 24AA      CLR	R10
(0242) 					Writecommand(AC_TABLE[8*x+y]);
    01BD E088      LDI	R24,0x8
    01BE 9D8A      MUL	R24,R10
    01BF 01F0      MOVW	R30,R0
    01C0 2E26      MOV	R2,R22
    01C1 2433      CLR	R3
    01C2 0DE2      ADD	R30,R2
    01C3 1DF3      ADC	R31,R3
    01C4 E080      LDI	R24,0
    01C5 E091      LDI	R25,1
    01C6 0FE8      ADD	R30,R24
    01C7 1FF9      ADC	R31,R25
    01C8 8100      LDD	R16,Z+0
    01C9 DF5C      RCALL	_Writecommand
(0243) 				}
(0244) 			Writedata(*data);
    01CA 01FA      MOVW	R30,R20
    01CB 8100      LDD	R16,Z+0
    01CC DF70      RCALL	_Writedata
(0245) 			y++;
    01CD 9563      INC	R22
    01CE 5F4F      SUBI	R20,0xFF
    01CF 4F5F      SBCI	R21,0xFF
    01D0 01FA      MOVW	R30,R20
    01D1 8020      LDD	R2,Z+0
    01D2 2022      TST	R2
    01D3 F709      BNE	0x01B5
    01D4 940E0419  CALL	pop_gset3
    01D6 9508      RET
_LcmClearTXT:
  i                    --> R20
    01D7 940E0424  CALL	push_gset1
(0246) 		}
(0247) }
(0248) 
(0249) /**************************************************************
(0250) * 函数名称：LcmClearTXT()
(0251) * 函数功能：清文本区RAM数据
(0252) * 入口参数：无
(0253) * 出口参数：无
(0254) **************************************************************/
(0255) void LcmClearTXT()
(0256) {
(0257)      uchar i;
(0258)      Writecommand(0x30);                       //8BitMCU,基本指令集合
    01D9 E300      LDI	R16,0x30
    01DA DF4B      RCALL	_Writecommand
(0259)      Writecommand(0x80);                       //AC归起始位
    01DB E800      LDI	R16,0x80
    01DC DF49      RCALL	_Writecommand
(0260)      for(i=0;i<64;i++)
    01DD 2744      CLR	R20
    01DE C003      RJMP	0x01E2
(0261)         Writedata(0x20);                           //地址归位
    01DF E200      LDI	R16,0x20
    01E0 DF5C      RCALL	_Writedata
    01E1 9543      INC	R20
    01E2 3440      CPI	R20,0x40
    01E3 F3D8      BCS	0x01DF
    01E4 940E0427  CALL	pop_gset1
    01E6 9508      RET
(0262) } 
(0263) 
(0264) /**************************************************************
(0265) * 函数名称：Init_12864()			
(0266) * 函数功能：初始化12864
(0267) * 入口参数：无
(0268) * 出口参数：无
(0269) **************************************************************/
(0270) void Init_12864(void)			
(0271) {
(0272) 	delay_ms(50); 			                           //用延时代替读忙，以避免死机
_Init_12864:
    01E7 E302      LDI	R16,0x32
    01E8 E010      LDI	R17,0
    01E9 DECA      RCALL	_delay_ms
(0273)      Writecommand(0x30);                           //8BitMCU,基本指令集合
    01EA E300      LDI	R16,0x30
    01EB DF3A      RCALL	_Writecommand
(0274)      Writecommand(0x03);                           //AC归0,不改变DDRAM内容
    01EC E003      LDI	R16,3
    01ED DF38      RCALL	_Writecommand
(0275)      Writecommand(0x0C);                           //显示ON,游标OFF,游标位反白OFF
    01EE E00C      LDI	R16,0xC
    01EF DF36      RCALL	_Writecommand
(0276)      Writecommand(0x01);                           //清屏,AC归0
    01F0 E001      LDI	R16,1
    01F1 DF34      RCALL	_Writecommand
(0277)      Writecommand(0x06);                           //写入时,游标右移动
    01F2 E006      LDI	R16,6
    01F3 DF32      RCALL	_Writecommand
    01F4 9508      RET
FILE: C:\DOCUME~1\Administrator\桌面\程序\colour_identify.c
(0001) /*******************************************
(0002) * 文件名： 
(0003) * 功能： 
(0004) * 说明： 
(0005) /********************************************/
(0006) #include <iom128v.h>
(0007) #include <macros.h>
(0008) #include "12864.h"
(0009) 
(0010) //颜色识别器色光滤波器选择：红色(S2,S3=0,0)，蓝色(S2,S3=0,1)，绿色(S2,S3=1,1)
(0011) #define S2 _PC7
(0012) #define S3 _PC6
(0013) 
(0014) //变量、常量定义
(0015) volatile uchar red=0,blue=0,green=0,flag=0,i=0,j=0,data[5]={0};
(0016) volatile uint counter=0;
(0017) 
(0018) //中断定义
(0019) #pragma interrupt_handler interrupt_int2:4 
(0020) #pragma interrupt_handler interrupt_timer1:15
(0021) 
(0022) /*******************************************
(0023) * 函数名称: int2_init()
(0024) * 函数功能: 外部中断2初始化
(0025) * 入口参数: 无
(0026) * 出口参数: 无
(0027) /********************************************/
(0028) void int2_init() 
(0029) {
(0030)    DDRD &= ~BIT(2);//中断引脚设置为输入
_int2_init:
    01F5 988A      CBI	0x11,2
(0031)    PORTD |= BIT(2); //设置输出口上拉
    01F6 9A92      SBI	0x12,2
(0032)    EICRA = 0X20; //下降沿触发
    01F7 E280      LDI	R24,0x20
    01F8 9380006A  STS	0x6A,R24
    01FA 9508      RET
(0033) }
(0034) 
(0035) /*******************************************
(0036) * 函数名称: timer1_init()
(0037) * 函数功能: 定时器1初始化
(0038) * 入口参数: 无
(0039) * 出口参数: 无
(0040) /********************************************/
(0041) void timer1_init()
(0042) {
(0043)     TCCR1B = 0X02;// 设置分频数为8
_timer1_init:
    01FB E082      LDI	R24,2
    01FC BD8E      OUT	0x2E,R24
(0044) 	TCNT1H = 0x63;// 设置计数初值, 定时20ms
    01FD E683      LDI	R24,0x63
    01FE BD8D      OUT	0x2D,R24
(0045)     TCNT1L = 0xC0;
    01FF EC80      LDI	R24,0xC0
    0200 BD8C      OUT	0x2C,R24
    0201 9508      RET
(0046) }
(0047) /*******************************************
(0048) * 函数名称: port_init()
(0049) * 函数功能: 端口初始化
(0050) * 入口参数: 无
(0051) * 出口参数: 无
(0052) /********************************************/
(0053) void port_init()
(0054) {
(0055)    DDRA = 0XFF;//PORTA3~0为液晶数据线
_port_init:
    0202 EF8F      LDI	R24,0xFF
    0203 BB8A      OUT	0x1A,R24
(0056)    DDRC = 0XFF;//控制S2与S3  
    0204 BB84      OUT	0x14,R24
    0205 9508      RET
_main:
    0206 9722      SBIW	R28,2
(0057) }
(0058) 
(0059) /*******************************************
(0060) * 函数名称:  main()
(0061) /********************************************/
(0062) void main(void)
(0063) {   
(0064)    port_init();
    0207 DFFA      RCALL	_port_init
(0065)    int2_init();
    0208 DFEC      RCALL	_int2_init
(0066)    timer1_init();
    0209 DFF1      RCALL	_timer1_init
(0067)    Init_12864();  
    020A DFDC      RCALL	_Init_12864
(0068)    LcmClearTXT(); //文本区清RAM函数
    020B DFCB      RCALL	_LcmClearTXT
(0069)    Display_x_y_data(0,0,"颜色识别：");
    020C E687      LDI	R24,0x67
    020D E091      LDI	R25,1
    020E 8399      STD	Y+1,R25
    020F 8388      STD	Y+0,R24
    0210 2722      CLR	R18
    0211 2700      CLR	R16
    0212 DF8E      RCALL	_Display_x_y_data
(0070)    Display_x_y_data(1,0,"红色成分：");
    0213 E58C      LDI	R24,0x5C
    0214 E091      LDI	R25,1
    0215 8399      STD	Y+1,R25
    0216 8388      STD	Y+0,R24
    0217 2722      CLR	R18
    0218 E001      LDI	R16,1
    0219 DF87      RCALL	_Display_x_y_data
(0071)    Display_x_y_data(2,0,"蓝色成分：");
    021A E581      LDI	R24,0x51
    021B E091      LDI	R25,1
    021C 8399      STD	Y+1,R25
    021D 8388      STD	Y+0,R24
    021E 2722      CLR	R18
    021F E002      LDI	R16,2
    0220 DF80      RCALL	_Display_x_y_data
(0072)    Display_x_y_data(3,0,"绿色成分：");
    0221 E486      LDI	R24,0x46
    0222 E091      LDI	R25,1
    0223 8399      STD	Y+1,R25
    0224 8388      STD	Y+0,R24
    0225 2722      CLR	R18
    0226 E003      LDI	R16,3
    0227 DF79      RCALL	_Display_x_y_data
(0073)    S2=0;//先检测红色(S2,S3=0,0)
    0228 B385      IN	R24,0x15
    0229 778F      ANDI	R24,0x7F
    022A BB85      OUT	0x15,R24
(0074)    S3=0;
    022B B385      IN	R24,0x15
    022C 7B8F      ANDI	R24,0xBF
    022D BB85      OUT	0x15,R24
(0075)    SEI();
    022E 9478      BSET	7
(0076)    EIMSK |= BIT(2); //打开外部中断
    022F B789      IN	R24,0x39
    0230 6084      ORI	R24,4
    0231 BF89      OUT	0x39,R24
(0077)    TIMSK |=  BIT(2);//打开溢出中断
    0232 B787      IN	R24,0x37
    0233 6084      ORI	R24,4
    0234 BF87      OUT	0x37,R24
(0078)    while(1);  
    0235 CFFF      RJMP	0x0235
    0236 9622      ADIW	R28,2
    0237 9508      RET
_interrupt_int2:
    0238 938A      ST	R24,-Y
    0239 939A      ST	R25,-Y
    023A B78F      IN	R24,0x3F
    023B 938A      ST	R24,-Y
(0079) }
(0080) 
(0081)  /*******************************************
(0082) * 函数名称:  interrupt_int2()  
(0083) * 函数功能: 
(0084) * 入口参数: 无
(0085) * 出口参数: 无
(0086) /********************************************/
(0087) void interrupt_int2()  
(0088) {  
(0089) 	counter++;
    023C 9180012B  LDS	R24,counter
    023E 9190012C  LDS	R25,counter+1
    0240 9601      ADIW	R24,1
    0241 9390012C  STS	counter+1,R25
    0243 9380012B  STS	counter,R24
    0245 9189      LD	R24,Y+
    0246 BF8F      OUT	0x3F,R24
    0247 9199      LD	R25,Y+
    0248 9189      LD	R24,Y+
    0249 9518      RETI
_interrupt_timer1:
    024A 940E043B  CALL	push_lset
    024C 9722      SBIW	R28,2
(0090) }
(0091) 
(0092) /*******************************************
(0093) * 函数名称: interrupt_timer1()
(0094) * 函数功能: 
(0095) * 入口参数: 无
(0096) * 出口参数: 无
(0097) /********************************************/
(0098) void interrupt_timer1()
(0099) {
(0100)     CLI();//关总中断
    024D 94F8      BCLR	7
(0101)     TCCR1B = 0X00;//定时器停止工作
    024E 2422      CLR	R2
    024F BC2E      OUT	0x2E,R2
(0102) 	TIMSK &= ~ BIT(2);//关闭溢出中断
    0250 B787      IN	R24,0x37
    0251 7F8B      ANDI	R24,0xFB
    0252 BF87      OUT	0x37,R24
(0103) 	EIMSK &= ~BIT(2); //关闭外部中断      	
    0253 B789      IN	R24,0x39
    0254 7F8B      ANDI	R24,0xFB
    0255 BF89      OUT	0x39,R24
(0104) 	flag++;//实现先检测红色,再检测蓝色,然后检测绿色,循环检测
    0256 91800123  LDS	R24,flag
    0258 5F8F      SUBI	R24,0xFF
    0259 93800123  STS	flag,R24
(0105) 	if(flag==1)
    025B 91800123  LDS	R24,flag
    025D 3081      CPI	R24,1
    025E F009      BEQ	0x0260
    025F C05D      RJMP	0x02BD
(0106) 	{   		 
(0107) 		 red=counter;
    0260 9020012B  LDS	R2,counter
    0262 9030012C  LDS	R3,counter+1
    0264 92200120  STS	red,R2
(0108) 		 data[0]=counter/100+0x30;		 
    0266 E624      LDI	R18,0x64
    0267 E030      LDI	R19,0
    0268 9100012B  LDS	R16,counter
    026A 9110012C  LDS	R17,counter+1
    026C 940E03FC  CALL	div16u
    026E 01C8      MOVW	R24,R16
    026F 96C0      ADIW	R24,0x30
    0270 93800126  STS	data,R24
(0109) 		 counter=counter%100;
    0272 E624      LDI	R18,0x64
    0273 E030      LDI	R19,0
    0274 9100012B  LDS	R16,counter
    0276 9110012C  LDS	R17,counter+1
    0278 940E03FA  CALL	mod16u
    027A 9310012C  STS	counter+1,R17
    027C 9300012B  STS	counter,R16
(0110) 		 data[1]=counter/10+0x30;
    027E E02A      LDI	R18,0xA
    027F E030      LDI	R19,0
    0280 9100012B  LDS	R16,counter
    0282 9110012C  LDS	R17,counter+1
    0284 940E03FC  CALL	div16u
    0286 01C8      MOVW	R24,R16
    0287 96C0      ADIW	R24,0x30
    0288 93800127  STS	data+1,R24
(0111) 		 counter=counter%10;
    028A E02A      LDI	R18,0xA
    028B E030      LDI	R19,0
    028C 9100012B  LDS	R16,counter
    028E 9110012C  LDS	R17,counter+1
    0290 940E03FA  CALL	mod16u
    0292 9310012C  STS	counter+1,R17
    0294 9300012B  STS	counter,R16
(0112) 		 data[2]=counter+0x30;		
    0296 9180012B  LDS	R24,counter
    0298 9190012C  LDS	R25,counter+1
    029A 96C0      ADIW	R24,0x30
    029B 93800128  STS	data+2,R24
(0113)    		 Locate_x_y(1,5);	
    029D E025      LDI	R18,5
    029E E001      LDI	R16,1
    029F DEB4      RCALL	_Locate_x_y
(0114)    		 for(i=0;i<3;i++)	    
    02A0 2422      CLR	R2
    02A1 92200124  STS	i,R2
    02A3 C00E      RJMP	0x02B2
(0115) 	     		 Writedata(data[i]);    		
    02A4 E286      LDI	R24,0x26
    02A5 E091      LDI	R25,1
    02A6 91E00124  LDS	R30,i
    02A8 27FF      CLR	R31
    02A9 0FE8      ADD	R30,R24
    02AA 1FF9      ADC	R31,R25
    02AB 8100      LDD	R16,Z+0
    02AC DE90      RCALL	_Writedata
    02AD 91800124  LDS	R24,i
    02AF 5F8F      SUBI	R24,0xFF
    02B0 93800124  STS	i,R24
    02B2 91800124  LDS	R24,i
    02B4 3083      CPI	R24,3
    02B5 F370      BCS	0x02A4
(0116) 		S2=0;//下次检测蓝色(S2,S3=0,1)
    02B6 B385      IN	R24,0x15
    02B7 778F      ANDI	R24,0x7F
    02B8 BB85      OUT	0x15,R24
(0117) 		S3=1;		
    02B9 B385      IN	R24,0x15
    02BA 6480      ORI	R24,0x40
    02BB BB85      OUT	0x15,R24
(0118) 	}
    02BC C126      RJMP	0x03E3
(0119) 	else if(flag==2)
    02BD 91800123  LDS	R24,flag
    02BF 3082      CPI	R24,2
    02C0 F009      BEQ	0x02C2
    02C1 C05D      RJMP	0x031F
(0120) 	{
(0121)    		 blue=counter;
    02C2 9020012B  LDS	R2,counter
    02C4 9030012C  LDS	R3,counter+1
    02C6 92200121  STS	blue,R2
(0122) 		 data[0]=counter/100+0x30;		 
    02C8 E624      LDI	R18,0x64
    02C9 E030      LDI	R19,0
    02CA 9100012B  LDS	R16,counter
    02CC 9110012C  LDS	R17,counter+1
    02CE 940E03FC  CALL	div16u
    02D0 01C8      MOVW	R24,R16
    02D1 96C0      ADIW	R24,0x30
    02D2 93800126  STS	data,R24
(0123) 		 counter=counter%100;
    02D4 E624      LDI	R18,0x64
    02D5 E030      LDI	R19,0
    02D6 9100012B  LDS	R16,counter
    02D8 9110012C  LDS	R17,counter+1
    02DA 940E03FA  CALL	mod16u
    02DC 9310012C  STS	counter+1,R17
    02DE 9300012B  STS	counter,R16
(0124) 		 data[1]=counter/10+0x30;
    02E0 E02A      LDI	R18,0xA
    02E1 E030      LDI	R19,0
    02E2 9100012B  LDS	R16,counter
    02E4 9110012C  LDS	R17,counter+1
    02E6 940E03FC  CALL	div16u
    02E8 01C8      MOVW	R24,R16
    02E9 96C0      ADIW	R24,0x30
    02EA 93800127  STS	data+1,R24
(0125) 		 counter=counter%10;
    02EC E02A      LDI	R18,0xA
    02ED E030      LDI	R19,0
    02EE 9100012B  LDS	R16,counter
    02F0 9110012C  LDS	R17,counter+1
    02F2 940E03FA  CALL	mod16u
    02F4 9310012C  STS	counter+1,R17
    02F6 9300012B  STS	counter,R16
(0126) 		 data[2]=counter+0x30;		
    02F8 9180012B  LDS	R24,counter
    02FA 9190012C  LDS	R25,counter+1
    02FC 96C0      ADIW	R24,0x30
    02FD 93800128  STS	data+2,R24
(0127)    		 Locate_x_y(2,5);	
    02FF E025      LDI	R18,5
    0300 E002      LDI	R16,2
    0301 DE52      RCALL	_Locate_x_y
(0128)    		 for(i=0;i<3;i++)	    
    0302 2422      CLR	R2
    0303 92200124  STS	i,R2
    0305 C00E      RJMP	0x0314
(0129) 	     		 Writedata(data[i]);    			
    0306 E286      LDI	R24,0x26
    0307 E091      LDI	R25,1
    0308 91E00124  LDS	R30,i
    030A 27FF      CLR	R31
    030B 0FE8      ADD	R30,R24
    030C 1FF9      ADC	R31,R25
    030D 8100      LDD	R16,Z+0
    030E DE2E      RCALL	_Writedata
    030F 91800124  LDS	R24,i
    0311 5F8F      SUBI	R24,0xFF
    0312 93800124  STS	i,R24
    0314 91800124  LDS	R24,i
    0316 3083      CPI	R24,3
    0317 F370      BCS	0x0306
(0130) 		S2=1;//下次检测绿色(S2,S3=1,1)
    0318 B385      IN	R24,0x15
    0319 6880      ORI	R24,0x80
    031A BB85      OUT	0x15,R24
(0131) 		S3=1;
    031B B385      IN	R24,0x15
    031C 6480      ORI	R24,0x40
    031D BB85      OUT	0x15,R24
(0132) 	}
    031E C0C4      RJMP	0x03E3
(0133)     else if(flag==3)
    031F 91800123  LDS	R24,flag
    0321 3083      CPI	R24,3
    0322 F009      BEQ	0x0324
    0323 C05D      RJMP	0x0381
(0134) 	{
(0135)    		 green=counter;
    0324 9020012B  LDS	R2,counter
    0326 9030012C  LDS	R3,counter+1
    0328 92200122  STS	green,R2
(0136) 		 data[0]=counter/100+0x30;		 
    032A E624      LDI	R18,0x64
    032B E030      LDI	R19,0
    032C 9100012B  LDS	R16,counter
    032E 9110012C  LDS	R17,counter+1
    0330 940E03FC  CALL	div16u
    0332 01C8      MOVW	R24,R16
    0333 96C0      ADIW	R24,0x30
    0334 93800126  STS	data,R24
(0137) 		 counter=counter%100;
    0336 E624      LDI	R18,0x64
    0337 E030      LDI	R19,0
    0338 9100012B  LDS	R16,counter
    033A 9110012C  LDS	R17,counter+1
    033C 940E03FA  CALL	mod16u
    033E 9310012C  STS	counter+1,R17
    0340 9300012B  STS	counter,R16
(0138) 		 data[1]=counter/10+0x30;
    0342 E02A      LDI	R18,0xA
    0343 E030      LDI	R19,0
    0344 9100012B  LDS	R16,counter
    0346 9110012C  LDS	R17,counter+1
    0348 940E03FC  CALL	div16u
    034A 01C8      MOVW	R24,R16
    034B 96C0      ADIW	R24,0x30
    034C 93800127  STS	data+1,R24
(0139) 		 counter=counter%10;
    034E E02A      LDI	R18,0xA
    034F E030      LDI	R19,0
    0350 9100012B  LDS	R16,counter
    0352 9110012C  LDS	R17,counter+1
    0354 940E03FA  CALL	mod16u
    0356 9310012C  STS	counter+1,R17
    0358 9300012B  STS	counter,R16
(0140) 		 data[2]=counter+0x30;	
    035A 9180012B  LDS	R24,counter
    035C 9190012C  LDS	R25,counter+1
    035E 96C0      ADIW	R24,0x30
    035F 93800128  STS	data+2,R24
(0141)    		 Locate_x_y(3,5);	
    0361 E025      LDI	R18,5
    0362 E003      LDI	R16,3
    0363 DDF0      RCALL	_Locate_x_y
(0142)    		 for(i=0;i<3;i++)	    
    0364 2422      CLR	R2
    0365 92200124  STS	i,R2
    0367 C00E      RJMP	0x0376
(0143) 	     		 Writedata(data[i]);   				 
    0368 E286      LDI	R24,0x26
    0369 E091      LDI	R25,1
    036A 91E00124  LDS	R30,i
    036C 27FF      CLR	R31
    036D 0FE8      ADD	R30,R24
    036E 1FF9      ADC	R31,R25
    036F 8100      LDD	R16,Z+0
    0370 DDCC      RCALL	_Writedata
    0371 91800124  LDS	R24,i
    0373 5F8F      SUBI	R24,0xFF
    0374 93800124  STS	i,R24
    0376 91800124  LDS	R24,i
    0378 3083      CPI	R24,3
    0379 F370      BCS	0x0368
(0144) 		S2=0;//下次检测红色(S2,S3=0,0)
    037A B385      IN	R24,0x15
    037B 778F      ANDI	R24,0x7F
    037C BB85      OUT	0x15,R24
(0145) 		S3=0;
    037D B385      IN	R24,0x15
    037E 7B8F      ANDI	R24,0xBF
    037F BB85      OUT	0x15,R24
(0146) 	}
    0380 C062      RJMP	0x03E3
(0147) 	else if(flag==4) 
    0381 91800123  LDS	R24,flag
    0383 3084      CPI	R24,4
    0384 F009      BEQ	0x0386
    0385 C05D      RJMP	0x03E3
(0148) 	{      
(0149) 	     flag=0;		 
    0386 2422      CLR	R2
    0387 92200123  STS	flag,R2
(0150) 		 if((red+5)>(blue+green))		 
    0389 90200122  LDS	R2,green
    038B 90300121  LDS	R3,blue
    038D 0C32      ADD	R3,R2
    038E 91800120  LDS	R24,red
    0390 5F8B      SUBI	R24,0xFB
    0391 1638      CP	R3,R24
    0392 F440      BCC	0x039B
(0151) 		     Display_x_y_data(0,5,"红色");
    0393 E481      LDI	R24,0x41
    0394 E091      LDI	R25,1
    0395 8399      STD	Y+1,R25
    0396 8388      STD	Y+0,R24
    0397 E025      LDI	R18,5
    0398 2700      CLR	R16
    0399 DE07      RCALL	_Display_x_y_data
    039A C048      RJMP	0x03E3
(0152) 		 else if((blue+8>red)&&(blue+2>green))
    039B 90200120  LDS	R2,red
    039D 91800121  LDS	R24,blue
    039F 5F88      SUBI	R24,0xF8
    03A0 1628      CP	R2,R24
    03A1 F478      BCC	0x03B1
    03A2 90200122  LDS	R2,green
    03A4 91800121  LDS	R24,blue
    03A6 5F8E      SUBI	R24,0xFE
    03A7 1628      CP	R2,R24
    03A8 F440      BCC	0x03B1
(0153) 		     Display_x_y_data(0,5,"蓝色");		
    03A9 E38C      LDI	R24,0x3C
    03AA E091      LDI	R25,1
    03AB 8399      STD	Y+1,R25
    03AC 8388      STD	Y+0,R24
    03AD E025      LDI	R18,5
    03AE 2700      CLR	R16
    03AF DDF1      RCALL	_Display_x_y_data
    03B0 C032      RJMP	0x03E3
(0154) 		 else if((green-3<red)&&(green-15>blue))
    03B1 90200120  LDS	R2,red
    03B3 91800122  LDS	R24,green
    03B5 5083      SUBI	R24,3
    03B6 1582      CP	R24,R2
    03B7 F478      BCC	0x03C7
    03B8 90200121  LDS	R2,blue
    03BA 91800122  LDS	R24,green
    03BC 508F      SUBI	R24,0xF
    03BD 1628      CP	R2,R24
    03BE F440      BCC	0x03C7
(0155) 		     Display_x_y_data(0,5,"黄色");	  	
    03BF E387      LDI	R24,0x37
    03C0 E091      LDI	R25,1
    03C1 8399      STD	Y+1,R25
    03C2 8388      STD	Y+0,R24
    03C3 E025      LDI	R18,5
    03C4 2700      CLR	R16
    03C5 DDDB      RCALL	_Display_x_y_data
    03C6 C01C      RJMP	0x03E3
(0156) 		 else if((green+5>red)&&(green>blue))
    03C7 90200120  LDS	R2,red
    03C9 91800122  LDS	R24,green
    03CB 5F8B      SUBI	R24,0xFB
    03CC 1628      CP	R2,R24
    03CD F470      BCC	0x03DC
    03CE 90200121  LDS	R2,blue
    03D0 90300122  LDS	R3,green
    03D2 1423      CP	R2,R3
    03D3 F440      BCC	0x03DC
(0157) 		     Display_x_y_data(0,5,"绿色");		   
    03D4 E382      LDI	R24,0x32
    03D5 E091      LDI	R25,1
    03D6 8399      STD	Y+1,R25
    03D7 8388      STD	Y+0,R24
    03D8 E025      LDI	R18,5
    03D9 2700      CLR	R16
    03DA DDC6      RCALL	_Display_x_y_data
    03DB C007      RJMP	0x03E3
(0158) 		/*else if((blue>red)&&(green>blue))
(0159) 		     Display_x_y_data(0,5,"白色");*/
(0160) 		 else
(0161) 		     Display_x_y_data(0,5,"未知");		 
    03DC E28D      LDI	R24,0x2D
    03DD E091      LDI	R25,1
    03DE 8399      STD	Y+1,R25
    03DF 8388      STD	Y+0,R24
    03E0 E025      LDI	R18,5
    03E1 2700      CLR	R16
    03E2 DDBE      RCALL	_Display_x_y_data
(0162) 	}
(0163) 	//delay_ms(200); 
(0164) 	counter = 0;//清零外中断计数标志		
    03E3 2422      CLR	R2
    03E4 2433      CLR	R3
    03E5 9230012C  STS	counter+1,R3
    03E7 9220012B  STS	counter,R2
(0165) 	TCCR1B = 0X02;// 设置分频数为8
    03E9 E082      LDI	R24,2
    03EA BD8E      OUT	0x2E,R24
(0166) 	TCNT1H = 0x63;//重新装入初值
    03EB E683      LDI	R24,0x63
    03EC BD8D      OUT	0x2D,R24
(0167)     TCNT1L = 0xC0;
    03ED EC80      LDI	R24,0xC0
    03EE BD8C      OUT	0x2C,R24
(0168) 	TIMSK |=  BIT(2);//打开溢出中断
    03EF B787      IN	R24,0x37
    03F0 6084      ORI	R24,4
    03F1 BF87      OUT	0x37,R24
(0169) 	EIMSK |= BIT(2); //打开外部中断		
    03F2 B789      IN	R24,0x39
    03F3 6084      ORI	R24,4
    03F4 BF89      OUT	0x39,R24
(0170) 	SEI();//开总中断
FILE: <library>
    03F5 9478      BSET	7
    03F6 9622      ADIW	R28,2
    03F7 940E0452  CALL	pop_lset
    03F9 9518      RETI
mod16u:
    03FA 9468      BSET	6
    03FB C001      RJMP	xdiv16u
div16u:
    03FC 94E8      BCLR	6
xdiv16u:
    03FD 92EA      ST	R14,-Y
    03FE 92FA      ST	R15,-Y
    03FF 938A      ST	R24,-Y
    0400 24EE      CLR	R14
    0401 24FF      CLR	R15
    0402 E180      LDI	R24,0x10
    0403 0F00      LSL	R16
    0404 1F11      ROL	R17
    0405 1CEE      ROL	R14
    0406 1CFF      ROL	R15
    0407 16E2      CP	R14,R18
    0408 06F3      CPC	R15,R19
    0409 F018      BCS	0x040D
    040A 1AE2      SUB	R14,R18
    040B 0AF3      SBC	R15,R19
    040C 9503      INC	R16
    040D 958A      DEC	R24
    040E F7A1      BNE	0x0403
    040F F416      BRTC	0x0412
    0410 2D0E      MOV	R16,R14
    0411 2D1F      MOV	R17,R15
    0412 9189      LD	R24,Y+
    0413 90F9      LD	R15,Y+
    0414 90E9      LD	R14,Y+
    0415 9508      RET
pop_gset2:
    0416 E0E2      LDI	R30,2
    0417 940C0428  JMP	pop
pop_gset3:
    0419 E0E4      LDI	R30,4
    041A 940C0428  JMP	pop
push_gset5:
    041C 92FA      ST	R15,-Y
    041D 92EA      ST	R14,-Y
push_gset4:
    041E 92DA      ST	R13,-Y
    041F 92CA      ST	R12,-Y
push_gset3:
    0420 92BA      ST	R11,-Y
    0421 92AA      ST	R10,-Y
push_gset2:
    0422 937A      ST	R23,-Y
    0423 936A      ST	R22,-Y
push_gset1:
    0424 935A      ST	R21,-Y
    0425 934A      ST	R20,-Y
    0426 9508      RET
pop_gset1:
    0427 E0E1      LDI	R30,1
pop:
    0428 9149      LD	R20,Y+
    0429 9159      LD	R21,Y+
    042A FDE0      SBRC	R30,0
    042B 9508      RET
    042C 9169      LD	R22,Y+
    042D 9179      LD	R23,Y+
    042E FDE1      SBRC	R30,1
    042F 9508      RET
    0430 90A9      LD	R10,Y+
    0431 90B9      LD	R11,Y+
    0432 FDE2      SBRC	R30,2
    0433 9508      RET
    0434 90C9      LD	R12,Y+
    0435 90D9      LD	R13,Y+
    0436 FDE3      SBRC	R30,3
    0437 9508      RET
    0438 90E9      LD	R14,Y+
    0439 90F9      LD	R15,Y+
    043A 9508      RET
push_lset:
    043B 93FA      ST	R31,-Y
    043C 93EA      ST	R30,-Y
    043D 93BA      ST	R27,-Y
    043E 93AA      ST	R26,-Y
    043F 939A      ST	R25,-Y
    0440 938A      ST	R24,-Y
    0441 933A      ST	R19,-Y
    0442 932A      ST	R18,-Y
    0443 931A      ST	R17,-Y
    0444 930A      ST	R16,-Y
    0445 929A      ST	R9,-Y
    0446 928A      ST	R8,-Y
    0447 927A      ST	R7,-Y
    0448 926A      ST	R6,-Y
    0449 925A      ST	R5,-Y
    044A 924A      ST	R4,-Y
    044B 923A      ST	R3,-Y
    044C 922A      ST	R2,-Y
    044D 921A      ST	R1,-Y
    044E 920A      ST	R0,-Y
    044F B60F      IN	R0,0x3F
    0450 920A      ST	R0,-Y
    0451 9508      RET
pop_lset:
    0452 9009      LD	R0,Y+
    0453 BE0F      OUT	0x3F,R0
    0454 9009      LD	R0,Y+
    0455 9019      LD	R1,Y+
    0456 9029      LD	R2,Y+
    0457 9039      LD	R3,Y+
    0458 9049      LD	R4,Y+
    0459 9059      LD	R5,Y+
    045A 9069      LD	R6,Y+
    045B 9079      LD	R7,Y+
    045C 9089      LD	R8,Y+
    045D 9099      LD	R9,Y+
    045E 9109      LD	R16,Y+
    045F 9119      LD	R17,Y+
    0460 9129      LD	R18,Y+
    0461 9139      LD	R19,Y+
    0462 9189      LD	R24,Y+
    0463 9199      LD	R25,Y+
    0464 91A9      LD	R26,Y+
    0465 91B9      LD	R27,Y+
    0466 91E9      LD	R30,Y+
    0467 91F9      LD	R31,Y+
    0468 9508      RET
